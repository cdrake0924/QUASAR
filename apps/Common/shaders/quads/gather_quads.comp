#include "quads_utils.glsl"

layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

layout(std430, binding = 0) buffer QuadBufferSizes {
    uint numProxies;
    uint numDepthOffsets;
};

layout(std430, binding = 1) readonly buffer normalSphericalDepthBufferInput {
    uint normalSphericalDepthInput[];
};

layout(std430, binding = 2) readonly buffer MetadataBufferInput {
    uint metadatasInput[];
};

layout(std430, binding = 3) writeonly buffer normalSphericalDepthBufferOutput {
    uint normalSphericalDepthOutput[];
};

layout(std430, binding = 4) writeonly buffer MetadataBufferOutput {
    uint metadatasOutput[];
};

uniform vec2 gBufferSize;
uniform vec2 quadMapSize;

QuadMapData loadInputQuadMap(ivec2 pixelCoord) {
    uint index = uint(pixelCoord.y) * uint(quadMapSize.x) + uint(pixelCoord.x);

    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSphericalDepth = normalSphericalDepthInput[index];
    quadMapDataPacked.metadata             = metadatasInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormal((quadMapDataPacked.normalSphericalDepth >> 16) & 0xFFFFu);
    quadMapData.depth  = unpackDepthUNORM16(quadMapDataPacked.normalSphericalDepth & 0xFFFFu);

    quadMapData.offset.x = (quadMapDataPacked.metadata >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.metadata >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.metadata & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0;

    return quadMapData;
}

void storeOutputQuadMap(in uint index, in QuadMapData quadMapData) {
    QuadMapDataPacked quadMapDataPacked;

    uint flattenedAndSize = ((quadMapData.size & 0x7Fu) << 1) | (quadMapData.flattened ? 1u : 0u);
    quadMapDataPacked.metadata = ((quadMapData.offset.x & 0xFFFu) << 20) |
                                 ((quadMapData.offset.y & 0xFFFu) <<  8) |
                                 (flattenedAndSize & 0xFFu);
    normalSphericalDepthOutput[index] = ((packNormalToSpherical(quadMapData.normal) & 0xFFFFu) << 16) |
                                        (packDepthUNORM16(quadMapData.depth) & 0xFFFFu);
    metadatasOutput[index]            = quadMapDataPacked.metadata;
}

void main() {
    ivec2 quadMapPixelCoords = ivec2(gl_GlobalInvocationID.xy);
    if (quadMapPixelCoords.x >= int(quadMapSize.x) || quadMapPixelCoords.y >= int(quadMapSize.y)) {
        return;
    }

    QuadMapData quadMapData = loadInputQuadMap(quadMapPixelCoords);
    if (quadMapData.size == 0) {
        return;
    }

    uint size = 1 << quadMapData.size;
    bool flattened = quadMapData.flattened;
    if (!flattened) {
        // For (int i = 0; i < size; i++) {
        //     For (int j = 0; j < size; j++) {
        //         AtomicAdd(numDepthOffsets, 4);
        //     }
        // }
        atomicAdd(numDepthOffsets, size * size * 4);
    }

    uint index = atomicAdd(numProxies, 1);
    storeOutputQuadMap(index, quadMapData);
}
