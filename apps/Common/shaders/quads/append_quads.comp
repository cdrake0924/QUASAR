#include "quads_utils.glsl"

layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer NormalSphericalsBufferInput {
    uint normalSphericalsInput[];
};

layout(std430, binding = 1) readonly buffer DepthsBufferInput {
    float depthsInput[];
};

layout(std430, binding = 2) readonly buffer MetadatasBufferInput {
    uint metadatasInput[];
};

layout(std430, binding = 3) writeonly buffer NormalSphericalsBufferOutput {
    uint normalSphericalsOutput[];
};

layout(std430, binding = 4) writeonly buffer DepthsBufferOutput {
    float depthsOutput[];
};

layout(std430, binding = 5) writeonly buffer MetadatasBufferOutput {
    uint metadatasOutput[];
};

layout(r32ui, binding = 0) uniform writeonly uimage2D quadIndexMap;

uniform vec2 gBufferSize;
uniform uint currNumProxies;
uniform uint incomingNumProxies;

void quadIndexStore(ivec2 pixelCoords, uint index) {
    ivec2 dim = imageSize(quadIndexMap);
    if (pixelCoords.x < uint(dim.x) && pixelCoords.y < uint(dim.y)) {
        imageStore(quadIndexMap, pixelCoords, uvec4(index, 0, 0, 0));
    }
}

QuadMapData loadQuadMapInput(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = normalSphericalsInput[index];
    quadMapDataPacked.depth = depthsInput[index];
    quadMapDataPacked.metadata = metadatasInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormal(quadMapDataPacked.normalSpherical);
    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.offset.x = (quadMapDataPacked.metadata >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.metadata >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.metadata & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0u;

    return quadMapData;
}

void main() {
    uint incomingQuadIndex = gl_GlobalInvocationID.x;
    if (incomingQuadIndex >= incomingNumProxies) {
        return;
    }

    QuadMapData quadMapData = loadQuadMapInput(incomingQuadIndex);
    if (quadMapData.size == 0u) { // Ignore if quad is empty
        return;
    }

    uint outputQuadIndex = currNumProxies + incomingQuadIndex;

    // Store incomingQuadIndex into quadIndexMap
    uint size = 1u << quadMapData.size;
    uint halfSize = size / 2u;
    ivec2 proxyPlanePixelCoords = ivec2(quadMapData.offset);
    for (uint idx = 0u; idx < halfSize * halfSize; idx++) {
        uint i = idx % halfSize;
        uint j = idx / halfSize;
        ivec2 pixelCoords = proxyPlanePixelCoords + ivec2(i, j);
        quadIndexStore(pixelCoords, outputQuadIndex);
    }

    // Append the quad map data
    normalSphericalsOutput[outputQuadIndex] = normalSphericalsInput[incomingQuadIndex];
    depthsOutput[outputQuadIndex] = depthsInput[incomingQuadIndex];
    metadatasOutput[outputQuadIndex] = metadatasInput[incomingQuadIndex];
}
