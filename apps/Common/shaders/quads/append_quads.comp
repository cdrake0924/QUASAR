#include "quads_utils.glsl"

layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer normalSphericalDepthBufferInput {
    uint normalSphericalDepthInput[];
};

layout(std430, binding = 1) readonly buffer MetadatasBufferInput {
    uint metadatasInput[];
};

layout(std430, binding = 2) writeonly buffer normalSphericalDepthBufferOutput {
    uint normalSphericalDepthOutput[];
};

layout(std430, binding = 3) writeonly buffer MetadatasBufferOutput {
    uint metadatasOutput[];
};

layout(std430, binding = 4) writeonly buffer QuadCreatedFlags {
    int quadCreatedFlags[];
};

layout(std430, binding = 5) writeonly buffer QuadIndexMap {
    uint quadIndexMap[];
};

uniform vec2 gBufferSize;
uniform uint currNumProxies;
uniform uint newNumProxies;

void quadIndexStore(ivec2 pixelCoords, uint index) {
    uint pixelIndex = uint(pixelCoords.y) * uint(gBufferSize.x) + uint(pixelCoords.x);
    quadIndexMap[pixelIndex] = index;
}

QuadMapData loadInputQuadMap(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSphericalDepth = normalSphericalDepthInput[index];
    quadMapDataPacked.metadata             = metadatasInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormal((quadMapDataPacked.normalSphericalDepth >> 16) & 0xFFFFu);
    quadMapData.depth  = unpackDepthUNORM16(quadMapDataPacked.normalSphericalDepth & 0xFFFFu);

    quadMapData.offset.x = (quadMapDataPacked.metadata >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.metadata >> 8) & 0xFFFu;

    uint sizeAlphaFlattened = quadMapDataPacked.metadata & 0xFFu;
    quadMapData.size      = (sizeAlphaFlattened >> 2) & 0x7Fu;
    quadMapData.hasAlpha  = (sizeAlphaFlattened & 2u) != 0u;
    quadMapData.flattened = (sizeAlphaFlattened & 1u) != 0u;

    return quadMapData;
}

void main() {
    uint quadIndex = gl_GlobalInvocationID.x;
    if (quadIndex >= newNumProxies) {
        return;
    }

    // Clear quadCreatedFlags
    quadCreatedFlags[quadIndex] = 0;

    if (quadIndex >= currNumProxies) {
        uint inputQuadIndex = quadIndex - currNumProxies;

        QuadMapData quadMapData = loadInputQuadMap(inputQuadIndex);
        if (quadMapData.size == 0u) { // Ignore if quad is empty
            return;
        }

        // Store quadIndex into quadIndexMap
        uint size = 1u << quadMapData.size;
        uint halfSize = size / 2u;
        ivec2 proxyPlanePixelCoords = ivec2(quadMapData.offset);
        for (uint idx = 0u; idx < halfSize * halfSize; idx++) {
            uint i = idx % halfSize;
            uint j = idx / halfSize;
            ivec2 pixelCoords = proxyPlanePixelCoords + ivec2(i, j);
            quadIndexStore(pixelCoords, quadIndex);
        }

        // Append the quad map data
        normalSphericalDepthOutput[quadIndex] = normalSphericalDepthInput[inputQuadIndex];
        metadatasOutput[quadIndex] = metadatasInput[inputQuadIndex];
    }
}
