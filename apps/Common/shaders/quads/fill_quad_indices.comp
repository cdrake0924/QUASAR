#include "quads_utils.glsl"

layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer NormalSphericalsBufferInput {
    uint normalSphericalsInput[];
};

layout(std430, binding = 1) readonly buffer DepthsBufferInput {
    float depthsInput[];
};

layout(std430, binding = 2) readonly buffer MetadatasBufferInput {
    uint metadatasInput[];
};

layout(std430, binding = 3) writeonly buffer NormalSphericalsBufferOutput {
    uint normalSphericalsOutput[];
};

layout(std430, binding = 4) writeonly buffer DepthsBufferOutput {
    float depthsOutput[];
};

layout(std430, binding = 5) writeonly buffer OffsetsBufferOutput {
    uint metadatasOutput[];
};

layout(std430, binding = 6) writeonly buffer quadIndicesMap {
    uint quadIndices[];
};

layout(std430, binding = 7) writeonly buffer quadCreatedBuffer {
    int quadCreatedFlags[];
};

uniform bool isReferenceFrame;
uniform vec2 gBufferSize;
uniform uint prevNumProxies;
uniform uint maxInvocations;

void storeQuadIndex(ivec2 pixelCoords, uint index) {
    uint pixelIndex = uint(pixelCoords.y) * uint(gBufferSize.x) + uint(pixelCoords.x);
    quadIndices[pixelIndex] = index;
}

QuadMapData loadQuadMap(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSpherical = normalSphericalsInput[index];
    quadMapDataPacked.depth = depthsInput[index];
    quadMapDataPacked.metadata = metadatasInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormal(quadMapDataPacked.normalSpherical);
    quadMapData.depth = quadMapDataPacked.depth;

    quadMapData.offset.x = (quadMapDataPacked.metadata >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.metadata >> 8) & 0xFFFu;

    uint flattenedAndSize = quadMapDataPacked.metadata & 0xFFu;
    quadMapData.size = (flattenedAndSize >> 1) & 0x7Fu;
    quadMapData.flattened = (flattenedAndSize & 1u) != 0u;

    return quadMapData;
}

void main() {
    uint quadIndex = gl_GlobalInvocationID.x;
    if (quadIndex >= maxInvocations) {
        return;
    }

    // Clear quadCreatedFlags
    quadCreatedFlags[quadIndex] = 0;

    QuadMapData quadMapData = loadQuadMap(quadIndex);
    if (quadMapData.size == 0u) {
        return;
    }

    // Uncomment for debugging:
    // ivec2 pixelCoords = ivec2(quadIndex % uint(gBufferSize.x), quadIndex / uint(gBufferSize.x));
    // storeQuadIndex(pixelCoords, quadIndex);

    uint startIndex = isReferenceFrame ? 0u : prevNumProxies;
    uint globalIndex = startIndex + quadIndex;
    normalSphericalsOutput[globalIndex] = normalSphericalsInput[quadIndex];
    depthsOutput[globalIndex] = depthsInput[quadIndex];
    metadatasOutput[globalIndex] = metadatasInput[quadIndex];

    uint size = 1u << quadMapData.size;
    uint halfSize = size / 2u;
    ivec2 proxyPlanePixelCoords = ivec2(quadMapData.offset);

    // Put quadIndex into quadIndices
    ivec2 baseCoord = proxyPlanePixelCoords;
    for (uint idx = 0u; idx < halfSize * halfSize; idx++) {
        uint i = idx % halfSize;
        uint j = idx / halfSize;
        ivec2 pixelCoords = baseCoord + ivec2(i, j);
        storeQuadIndex(pixelCoords, globalIndex);
    }
}
