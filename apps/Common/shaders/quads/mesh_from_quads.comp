#include "../camera_utils.glsl"
#include "quads_utils.glsl"

layout(local_size_x = THREADS_PER_LOCALGROUP, local_size_y = THREADS_PER_LOCALGROUP, local_size_z = 1) in;

struct Vertex {
    vec3 position;
    vec3 texCoord3D;
};

layout(std430, binding = 0) buffer MeshBufferSizes {
    uint numVertices;
    uint numIndices;
};

layout(std430, binding = 1) buffer VertexBuffer {
    Vertex vertices[];
};

layout(std430, binding = 2) buffer IndexBuffer {
    uint indices[];
};

layout(std430, binding = 3) buffer IndirectCommandBuffer {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
} indirectCommandBuffer;

layout(std430, binding = 4) readonly buffer normalSphericalDepthBufferInput {
    uint normalSphericalDepthInput[];
};

layout(std430, binding = 5) readonly buffer MetadatasBufferInput {
    uint metadatasInput[];
};

layout(std430, binding = 6) readonly buffer QuadCreatedFlags {
    int quadCreatedFlags[];
};

layout(std430, binding = 7) readonly buffer QuadIndexMap {
    uint quadIndexMap[];
};

uniform sampler2D alphaTexture;

layout(rgba16f, binding = 0) uniform readonly image2D depthOffsetsBuffer;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 viewInverse;
uniform mat4 projectionInverse;
uniform float near;
uniform float far;

uniform vec2 gBufferSize;
uniform uint currNumProxies;
uniform vec4 textureExtent;
uniform float expandUVAmount = 0.025;

#define VERTICES_IN_A_QUAD  4u
#define INDICES_IN_A_QUAD   6u
#define NUM_SUB_QUADS       4u

vec3 lineLineIntersection(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {
    vec3 d1 = p1 - p0;
    vec3 d2 = p3 - p2;
    vec3 r = p2 - p0;

    vec3 d1xd2 = cross(d1, d2);
    vec3 rxd2 = cross(r, d2);

    float denominator = dot(d1xd2, d1xd2);
    if (denominator < epsilon) {
        return vec3(0.0);
    }

    float t = dot(rxd2, d1xd2) / denominator;

    vec3 intersectionPoint = p0 + t * d1;
    return intersectionPoint;
}

QuadMapData loadQuadMap(uint index) {
    QuadMapDataPacked quadMapDataPacked;
    quadMapDataPacked.normalSphericalDepth = normalSphericalDepthInput[index];
    quadMapDataPacked.metadata             = metadatasInput[index];

    QuadMapData quadMapData;
    quadMapData.normal = unpackSphericalToNormal((quadMapDataPacked.normalSphericalDepth >> 16) & 0xFFFFu);
    quadMapData.depth  = unpackDepthUNORM16(quadMapDataPacked.normalSphericalDepth & 0xFFFFu);

    quadMapData.offset.x = (quadMapDataPacked.metadata >> 20) & 0xFFFu;
    quadMapData.offset.y = (quadMapDataPacked.metadata >> 8) & 0xFFFu;

    uint sizeAlphaFlattened = quadMapDataPacked.metadata & 0xFFu;
    quadMapData.size      = (sizeAlphaFlattened >> 2) & 0x7Fu;
    quadMapData.hasAlpha  = (sizeAlphaFlattened & 2u) != 0u;
    quadMapData.flattened = (sizeAlphaFlattened & 1u) != 0u;

    return quadMapData;
}

vec4 loadDepthOffsets(in ivec2 pixelCoord) {
    return imageLoad(depthOffsetsBuffer, pixelCoord);
}

uint loadQuadMapIndex(ivec2 pixelCoords) {
    uint pixelIndex = uint(pixelCoords.y) * uint(gBufferSize.x) + uint(pixelCoords.x);
    return quadIndexMap[pixelIndex];
}

Plane quadMapDataToPlane(in QuadMapData quadMapData) {
    Plane proxyPlane;

    uint halfSize = 1u << (quadMapData.size - 1u); // 2^size / 2
    vec2 proxyPlaneUV = (vec2(quadMapData.offset) + float(halfSize) * vec2(0.5)) / gBufferSize;
    float proxyPlaneDepth = quadMapData.depth;
    proxyPlane.normal = quadMapData.normal;

    vec2 proxyPlaneNDC = proxyPlaneUV * 2.0 - 1.0;
    proxyPlane.point = ndcToView(projectionInverse, proxyPlaneNDC, proxyPlaneDepth);

    return proxyPlane;
}

void createSurfel(in Quad2D surfelPixelCoords, in vec4 depthOffsets, in Plane proxyPlane, out Quad surfel, out Quad2D surfelUVs) {
    surfelUVs.bottomLeft  = (surfelPixelCoords.bottomLeft  + vec2(-expandUVAmount, -expandUVAmount)) / gBufferSize;
    surfelUVs.bottomRight = (surfelPixelCoords.bottomRight + vec2(+expandUVAmount, -expandUVAmount)) / gBufferSize;
    surfelUVs.topLeft     = (surfelPixelCoords.topLeft     + vec2(-expandUVAmount, +expandUVAmount)) / gBufferSize;
    surfelUVs.topRight    = (surfelPixelCoords.topRight    + vec2(+expandUVAmount, +expandUVAmount)) / gBufferSize;

    Quad2D surfelNDCs;
    surfelNDCs.bottomLeft  = surfelUVs.bottomLeft  * 2.0 - 1.0;
    surfelNDCs.bottomRight = surfelUVs.bottomRight * 2.0 - 1.0;
    surfelNDCs.topLeft     = surfelUVs.topLeft     * 2.0 - 1.0;
    surfelNDCs.topRight    = surfelUVs.topRight    * 2.0 - 1.0;

    Quad surfelNearPlane;
    surfelNearPlane.bottomLeft  = ndcToView(projectionInverse, surfelNDCs.bottomLeft, 0.0);
    surfelNearPlane.bottomRight = ndcToView(projectionInverse, surfelNDCs.bottomRight, 0.0);
    surfelNearPlane.topLeft     = ndcToView(projectionInverse, surfelNDCs.topLeft, 0.0);
    surfelNearPlane.topRight    = ndcToView(projectionInverse, surfelNDCs.topRight, 0.0);

    // Shoot rays from corners of the surfel to the plane to find the 3D intersection points
    Quad quadPtsOnPlane;
    quadPtsOnPlane.bottomLeft  = pointPlaneIntersection(surfelNearPlane.bottomLeft,  proxyPlane);
    quadPtsOnPlane.bottomRight = pointPlaneIntersection(surfelNearPlane.bottomRight, proxyPlane);
    quadPtsOnPlane.topLeft     = pointPlaneIntersection(surfelNearPlane.topLeft,     proxyPlane);
    quadPtsOnPlane.topRight    = pointPlaneIntersection(surfelNearPlane.topRight,    proxyPlane);

    // Apply depth offsets to the quad points
    surfel.bottomLeft  = quadPtsOnPlane.bottomLeft  + depthOffsets.x * normalize(quadPtsOnPlane.bottomLeft);
    surfel.bottomRight = quadPtsOnPlane.bottomRight + depthOffsets.y * normalize(quadPtsOnPlane.bottomRight);
    surfel.topLeft     = quadPtsOnPlane.topLeft     + depthOffsets.z * normalize(quadPtsOnPlane.topLeft);
    surfel.topRight    = quadPtsOnPlane.topRight    + depthOffsets.w * normalize(quadPtsOnPlane.topRight);
}

void uvToUVQ(in Quad quad, in Quad2D uvsSrc, out Quad uvsDst) {
    vec3 vertPositionsView[4] = vec3[4](quad.bottomLeft, quad.bottomRight, quad.topRight, quad.topLeft);

    // UV coordinates have to be in 3D to properly interpolate them in the fragment shader
    // To do this, add a q component to the uvs and the fragment shader will perform perspective-correct interpolation
    vec3 uvqs[4];
    uvqs[0] = vec3(mix(textureExtent.xy, textureExtent.zw, uvsSrc.bottomLeft),  1.0);
    uvqs[1] = vec3(mix(textureExtent.xy, textureExtent.zw, uvsSrc.bottomRight), 1.0);
    uvqs[2] = vec3(mix(textureExtent.xy, textureExtent.zw, uvsSrc.topRight),    1.0);
    uvqs[3] = vec3(mix(textureExtent.xy, textureExtent.zw, uvsSrc.topLeft),     1.0);

    // Adapted from:
    // https://www.roxlu.com/2014/026/mapping-a-texture-on-a-disc
    // and
    // https://www.reedbeta.com/blog/quadrilateral-interpolation-part-1/
    float vertDistanceToCenter[4];
    vec3 intersectPointView = lineLineIntersection(
                                vertPositionsView[0], vertPositionsView[2],
                                vertPositionsView[1], vertPositionsView[3]);
    for (int i = 0; i < 4; i++) {
        float dist = distance(intersectPointView, vertPositionsView[i]);
        vertDistanceToCenter[i] = dist;
    }
    for (int i = 0; i < 4; i++) {
        int i2 = (i + 2) % 4;
        uvqs[i] = uvqs[i] * ((vertDistanceToCenter[i] + vertDistanceToCenter[i2]) / vertDistanceToCenter[i2]);
    }

    uvsDst.bottomLeft  = uvqs[0];
    uvsDst.bottomRight = uvqs[1];
    uvsDst.topRight    = uvqs[2];
    uvsDst.topLeft     = uvqs[3];
}

void storeSurfel(in Quad quad, in Quad2D uvsSrc, in QuadMapData quadMapData) {
    /************************

            tl -- tr
            |   / |
            | /   |
            bl -- br

    ************************/

    uint vertexIdxBase = atomicAdd(numVertices, VERTICES_IN_A_QUAD);

    uint vertexIdxTopLeft = vertexIdxBase + 0u;
    vertices[vertexIdxTopLeft].position = viewToWorld(viewInverse, quad.topLeft);

    uint vertexIdxTopRight = vertexIdxBase + 1u;
    vertices[vertexIdxTopRight].position = viewToWorld(viewInverse, quad.topRight);

    uint vertexIdxBottomLeft = vertexIdxBase + 2u;
    vertices[vertexIdxBottomLeft].position = viewToWorld(viewInverse, quad.bottomLeft);

    uint vertexIdxBottomRight = vertexIdxBase + 3u;
    vertices[vertexIdxBottomRight].position = viewToWorld(viewInverse, quad.bottomRight);

    Quad uvqs;
    uvToUVQ(quad, uvsSrc, uvqs);
    vertices[vertexIdxBottomLeft].texCoord3D  = uvqs.bottomLeft;
    vertices[vertexIdxBottomRight].texCoord3D = uvqs.bottomRight;
    vertices[vertexIdxTopRight].texCoord3D    = uvqs.topRight;
    vertices[vertexIdxTopLeft].texCoord3D     = uvqs.topLeft;

    uint indexIdxBase = atomicAdd(numIndices, INDICES_IN_A_QUAD);

    indices[indexIdxBase + 0u] = vertexIdxBottomLeft;
    indices[indexIdxBase + 1u] = vertexIdxBottomRight;
    indices[indexIdxBase + 2u] = vertexIdxTopRight;

    indices[indexIdxBase + 3u] = vertexIdxTopRight;
    indices[indexIdxBase + 4u] = vertexIdxTopLeft;
    indices[indexIdxBase + 5u] = vertexIdxBottomLeft;
}

void storeSurfelsFromQuadMap(QuadMapData quadMapData) {
    // Extract the plane normal and point from the quad map
    Plane proxyPlane = quadMapDataToPlane(quadMapData);

    uint size = 1u << quadMapData.size;
    uint halfSize = size / 2u;
    float halfGridSize = float(size) * surfelSize / 2.0;
    vec2 proxyPlaneUV = (vec2(quadMapData.offset) + float(halfSize) * vec2(0.5)) / gBufferSize;
    vec2 proxyPlanePixelCoords = vec2(proxyPlaneUV * gBufferSize);

    bool flattened = quadMapData.flattened;
    if (!flattened) {
        // Create surfels for each subpixel in the quad map
        vec2 baseCoord = proxyPlanePixelCoords - vec2(halfGridSize);
        vec2 stepSize = vec2(surfelSize);
        for (uint idx = 0u; idx < size * size; idx++) {
            uint i = idx % size;
            uint j = idx / size;
            vec2 surfelBaseCoord = baseCoord + vec2(i, j) * stepSize;

            Quad2D surfelPixelCoords;
            surfelPixelCoords.bottomLeft  = surfelBaseCoord + vec2(0.0, 0.0);
            surfelPixelCoords.bottomRight = surfelBaseCoord + vec2(stepSize.x, 0.0);
            surfelPixelCoords.topLeft     = surfelBaseCoord + vec2(0.0, stepSize.y);
            surfelPixelCoords.topRight    = surfelBaseCoord + stepSize;

            ivec2 depthOffsetPixelCoords = 2 * ivec2(quadMapData.offset) + ivec2(i, j);
            vec4 depthOffsets = loadDepthOffsets(depthOffsetPixelCoords);
            Quad surfel; Quad2D surfelUVs;
            createSurfel(surfelPixelCoords, depthOffsets, proxyPlane, surfel, surfelUVs);
            storeSurfel(surfel, surfelUVs, quadMapData);
        }
    }
    else {
        // Create a single surfel for the quad map
        Quad2D surfelPixelCoords;
        surfelPixelCoords.bottomLeft  = proxyPlanePixelCoords + vec2(-halfGridSize, -halfGridSize);
        surfelPixelCoords.bottomRight = proxyPlanePixelCoords + vec2(+halfGridSize, -halfGridSize);
        surfelPixelCoords.topLeft     = proxyPlanePixelCoords + vec2(-halfGridSize, +halfGridSize);
        surfelPixelCoords.topRight    = proxyPlanePixelCoords + vec2(+halfGridSize, +halfGridSize);

        vec4 depthOffsets = vec4(0.0);
        Quad surfel; Quad2D surfelUVs;
        createSurfel(surfelPixelCoords, depthOffsets, proxyPlane, surfel, surfelUVs);
        storeSurfel(surfel, surfelUVs, quadMapData);
    }
}

void main() {
    uvec2 quadIndexMapPixelCoord = gl_GlobalInvocationID.xy;
    if (quadIndexMapPixelCoord.x >= uint(gBufferSize.x) || quadIndexMapPixelCoord.y >= uint(gBufferSize.y)) {
        return;
    }

    // Reset buffers on first invocation
    if (quadIndexMapPixelCoord == uvec2(0u)) {
        // Reset mesh buffers
        atomicExchange(numVertices, 0u);
        atomicExchange(numIndices, 0u);
        atomicExchange(indirectCommandBuffer.count, 0u);
    }

    uint quadMapIndex = loadQuadMapIndex(ivec2(quadIndexMapPixelCoord));
    if (quadMapIndex >= currNumProxies) {
        return;
    }

    // If the quad has already been created, skip it
    bool quadCreated = bool(atomicExchange(quadCreatedFlags[quadMapIndex], 1));
    if (quadCreated) {
        return;
    }

    QuadMapData quadMapData = loadQuadMap(quadMapIndex);
    storeSurfelsFromQuadMap(quadMapData);

    atomicExchange(indirectCommandBuffer.count, numIndices);
}
